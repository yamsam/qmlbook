
=========
Qt 5を始めよう
=========

.. sectionauthor:: `jryannel <https://github.com/jryannel>`_

.. issues:: ch01

.. note::

    この章のソースコードはこちらにあります `assets folder <../../assets>`_.

この本はQtバージョン5.xを用いたアプリケーション開発における様々な側面を紹介します。新技術Qt Quickを中心に、C++によるQt Quickのバックエンドや拡張の開発に必要な情報も紹介します。

この章ではQt 5の全体像を説明します。開発者の参考になるアプリケーションモデル、そして今後紹介することになるQt 5アプリケーションの見本をいち早くご紹介します。また、Qt5の中身の大まかな概要、および開発者との交流方法も紹介します。


はじめに
=======

.. rubric:: 歴史

Qt 4は2005年以来進化をつづけ、数千のアプリケーション、フルデスクトップおよびモバイルシステムへ強固な地盤を提供してきました。近年、コンピューターの使用形態は、据え置きPCから持ち運びできるノートブックへ、そして今ではモバイルコンピュータへと変遷しています。今や古なじみのデスクトップは、スクリーンに常時接続されたタッチベースのモバイルへとますます置き換わっています。それと共にデスクトップUXの設計思想も変わりました。かつてのWindows UIが主流であった時代に比べると、いまや開発者は多種多様なスクリーンとそのUI言語の中で多大の時間を費やしています。

Qt 4は主要な全てのプラットフォーム上で動作する一貫したUIウィジェットを持つ、デスクトップ開発の要求を満たすべく設計されました。今日、Qtユーザーの課題は変わりました。顧客が求めるタッチベースのユーザインタフェース、そして全ての主要なデスクトップとモバイルシステム上で動作するモダンなユーザーインターフェイスを作ることです。Qt 4.7は、Qt Quickテクノロジーを導入するために始まりました。Qt Quickはこうした顧客の要求に答える全く新しいUIを実現するための、シンプルな要素から構成されたユーザーインターフェースのコンポーネント群です。

Qt 5の狙い
---------

Qt 5はこれまでの成功してきたQt 4リリースを一新したものです。Qt 4.8で、すでにQt 4のリリースは約7年間に及びました。そして今、さらなる素晴らしいツールキットを作る時がきました。Qt5は以下の項目に重点を置いて開発されています。

* **優れたグラフィックス**: Qt Quick 2はOpenGL(ES)をベースとしたシーングラフを実装しています。再構成されたグラフィックススタックにより、この分野では前例のない使い易さを兼ね備えたこれまでにない次元のグラフィックエフェクトを実現します。

* **開発者の生産性**: UI制作の基本言語はQMLとJavaScriptです。バックエンドはC++で作成されます。JavaScriptとC ++の間の分割は高速なイタレーションを実現します。フロントエンドの開発者は優れたユーザーインターフェースの開発に、バックエンドのC++開発者は安定性とパフォーマンス、そしてランタイム拡張へとそれぞれ専念できるからです。 

* **クロスプラットフォームの移植性**:統合されたQtプラットフォームの抽象化により、広範囲のプラットフォームへの移植が迅速かつ簡単に行えるようになりました。Qt 5はQt Essentials とAddonsにより構成されています。これによりOS開発者はモジュール開発に専念すると同時に、ランタイムの小型化を可能にします。

* **Open Development**: Qtは現在、 `qt.io <http://qt.io>`_ に主催されるオープンソースガバナンスプロジェクトです。 開発はオープンなコミュニティによる運営が行われています。



Qt5 入門
=================


Qt Quick
--------

Qt Quickとは、Qt 5で用いられているユーザインターフェース技術の包括的な用語です。Qt Quickそのものは次のテクノロジーの集りです。

* QML - ユーザインタフェースのためのマークアップ言語です
* JavaScript - 動的なスクリプト言語です
* Qt C ++ - 移植性に優れた強力なC ++ライブラリです

.. figure:: ../../en/ch01/assets/qt5_overview.png


QMLはHTMLと同じマークアップ言語です。``Item {}`` のように中括弧で囲まれたエレメントと呼ばれるタグから構成されます。QMLは素早く簡単にユーザインタフェースの作成ができる可読性に優れた言語として一から設計されました。またJavaScriptを使ってユーザーインターフェースを強化することもできます。Qt Qtuickは、Qt C++で作成したネイティブの独自機能を用いて簡単に拡張することができます。つまり、宣言型のUIであるQMLがフロントエンドとなり、一方のQt C++によるネイティブ部分がバックエンドになります。これによって開発者はユーザインタフェースから計算負荷の高いアプリケーションのネイティブ機能を分離させることができます。

一般的なプロジェクトでは、フロントエンドはQMLとJavaScriptで開発され、システムとの仲介と力仕事を担当するバックエンドコードはQt C++で開発されます。この結果、デザインと機能の自然な分離が可能になります。典型的なバックエンドはQt独自のユニットテストフレームワークでテストされて、利用者となるフロントエンドの開発者に提供されます。


ユーザーインターフェイスの解説
---------------------------

ではQt Quickを使って簡単なユーザーインターフェースを作りましょう。この例を通じてQML言語の特徴を紹介します。最後には回転する羽をもった風車が完成します。


.. figure:: ../../en/ch01/assets/scene.png
    :scale: 50%


まず空のファイル ``main.qml`` をつくります。QMLファイルの拡張子は ``.qml`` です。マークアップ言語であるQMLファイルは、ルートエレメントを一つを持ちます。次の ``Image`` エレメントは背景画像に基づく幅と高さを持ちます。

.. code-block:: qml

    import QtQuick 2.5

    Image {
        id: root
        source: "images/background.png"
    }

QMLではルートエレメントの型に制限がありません。今回はルートエレメントとして、sourceプロパティに背景画像がセットされた ``Image`` エレメントを使うことにします。 


.. figure:: ../../en/ch01/src/showcase/images/background.png


.. note::

 エレメントはプロパティを持ちます。たとえばImageエレメントには ``width`` や ``height`` のほかにも ``source`` などのプロパティがあります。imageエレメントのサイズは、画像の大きさから自動的に求まります。さもなければ ``width`` と ``height`` プロパティに適切なピクセル値を設定する必要があります。

 冒頭のimport文でインクルードした ``QtQuick`` モジュールには標準のエレメントが含まれています。

 特別なプロパティである ``id`` は、必須ではありませんが、ドキュメント内の他の場所でこの要素を参照するための識別子です。重要： ``id`` プロパティをいったんセットした後に変更したり、実行中にセットすることができません。筆者はルートエレメントのidとして ``root`` をよく使います。大規模なQMLドキュメントであっても簡単に最上位のエレメントを参照できるからです。

ユーザーインターフェースの前景となる支柱と風車のエレメントは別々の画像として配置します。

.. figure:: ../../en/ch01/src/showcase/images/pole.png
.. figure:: ../../en/ch01/src/showcase/images/pinwheel.png

支柱は背景に対して水平方向の中心、底を一致させて配置する必要があります。風車は中央に配置します。

この例ではimageエレメントしか使用していませんが、一般的なユーザーインターフェースは様々なタイプのエレメントから構成されます。


.. code-block:: qml

  Image {
      id: root
      ...
      Image {
          id: pole
          anchors.horizontalCenter: parent.horizontalCenter
          anchors.bottom: parent.bottom
          source: "images/pole.png"
      }

      Image {
          id: wheel
          anchors.centerIn: parent
          source: "images/pinwheel.png"
      }
      ...
  }



風車を中央の位置に配置するために、 ``anchor（アンカー）`` と呼ばれる特別なプロパティを使用します。anchorを使えば、親や兄弟オブジェクトの間の幾何学的な相対位置を指定することができます。例えば親エレメントの中央にエレメントを配置する場合は（ ``anchors.centerIn: parent`` ）とします。使用可能な相対位置の指定は、オブジェクトの端のそれぞれについてleft, right, top, bottom, centerIn, fill, verticalCenterとhorizontalCenterが用意されています。アンカーは正確に一致させる必要があり、エレメントのtopとleftをアンカーしても意味がありません。

これで風車を背景の中央に配置できました。

.. note::

 時には中心からの位置を微調整したいことがあります。これは ``anchors.horizo​​ntalCenterOffset`` または ``anchors.verticalCenterOffset`` で行えます。他のアンカーでも同様の位置調節プロパティが利用できます。アンカープロパティの全リストはマニュアルを参照してください。

.. note::

 この例では ``Image`` エレメントをルートエレメントの子エレメントとして配置しました。これは宣言型言語の重要な概念を表しています。宣言型言語では、ユーザーインターフェースはレイヤーの順列とグループとして記述されます。まず最上層（長方形）のレイヤーが最初に描画され、次にその子エレメントがローカル座標系上でその上に描画されます。

例をすこし面白くするためにシーンをインタラクティブにしましょう。ユーザーがシーンのどこかでマウスを押したときにホイールを回転させることにします。


``MouseArea`` エレメントを使い、大きさをルートエレメントと同じ にします。

.. code-block:: qml

    Image {
        id: root
        ...
        MouseArea {
            anchors.fill: parent
            onClicked: wheel.rotation += 90
        }
        ...
    }

このエレメントはユーザーが範囲領域内をクリックしたときにシグナルを発行します。``onClicked`` 関数をオーバーライドするとこのシグナルにフックすることができます。この例では、エレメントwheelのrotationを+90°に変更します。

.. note::

 この仕組みはすべてのシグナルで共通しています。命名規則は先頭を大文字にして ``on`` + ``SignalName`` です。プロパティは値が変更されたときにシグナルを発行します。命名規則は次のとおりです。

        ``on`` + ``PropertyName`` + ``Changed``

 例えば ``width`` プロパティが変化した場合、 ``onWidthChanged: print(width)`` で値を取得することができます。

これでwheelは回転するようになりましたが、まだ動きが滑らかではありません。rotationプロパティが即座に変更されてしまうからです。そこでプロパティの値が90°までゆっくりと変化するようにしたいと思います。ここでアニメーションの出番になります。アニメーションはプロパティの変更が、ある期間どのように分割されるかを定義します。これを可能にするには、プロパティのふるまい​（behaviour）と呼ばれるアニメーションタイプを使用します。 ``Behaviour`` は定義済みプロパティへの変更に対応するアニメーションを指定します。要するにプロパティが変更されるたびにアニメーションが実行されます。この方法は数あるアニメーション定義方法の内の1つになります。

.. code-block:: qml

    Image {
        id: root
        Image {
            id: wheel
            Behavior on rotation {
                NumberAnimation {
                    duration: 250
                }
            }
        }
    }

これでwheelのrotationプロパティが変化するたびに、 ``NumberAnimation`` によって250ミリ秒間のアニメーションが行われます。つまり、250ミリ秒かかって90°回転します。

.. figure:: ../../en/ch01/assets/scene2.png
    :scale: 50%

.. note:: wheelはブラー表示されません。単に回転するだけです。ブラー効果のついたwheelはアッセットフォルダにあります。よろしければ試してみて下さい。


これでwheelの見栄えがよくなりました。QtQuickプログラミングのコツが少しはつかめたでしょうか。

Qt の構成要素
==================

Qt 5は多くのモジュールから構成されています。モジュールとは開発者が使うライブラリです。Qt対応プラットフォームで動作させるために必須のモジュールがあります。これらは *Qt Essentialsモジュール* と呼ばれます。必須ではないモジュールは *Qt Addonモジュール* と呼ばれます。開発者の大半は使用する必要がないと思いますが、共通課題の優れた解決策として知っておいて損はありません。

Qt モジュール
---------------------

Qt EssentialsはQt対応プラットフォームの必須モジュール群です。Qt Quick2を使用したモダンなQt 5アプリケーションを開発するための基盤となります。

.. rubric:: Core-Essential Modules

QMLプログラミングを開始するための最小限のモジュールです。

.. list-table::
    :widths: 20 80
    :header-rows: 1

    *   - モジュール
        - 説明
    *   - Qt Core
        - 中心となる非グラフィクスのクラス群。他のモジュールで使用される
    *   - Qt GUI
        - グラフィカルユーザーインターフェース(GUI)のクラス群。OpenGLを含む
    *   - Qt Multimedia
        - 音声、動画、ラジオ、カメラのクラス群
    *   - Qt Network
        - ネットワークプログラミングを容易かつよりポータブルにするためのクラス群
    *   - Qt QML
        - QMLとJavaScriptのためのクラス群.
    *   - Qt Quick
        -  カスタムユーザーインターフェースをそなえた高度にダイナミックなアプリケーションを構築するための宣言型フレームワーク
    *   - Qt SQL
        - SQLを使ったデータベース統合のクラス.
    *   - Qt Test
        - Qtアプリケーションとライブラリをユニットテストするためのクラス群.
    *   - Qt WebKit
        - WebKit2をベースとした実装と新しいQMLのAPIのクラス群。 アドオンモジュールのQt WebKitウィジェットを併せて参照してください.
    *   - Qt WebKit Widgets
        - Qt 4で実装されたWebKit1とQWidgetベースのクラスです。 
    *   - Qt Widgets
        - C++ウィジェットでQtGuiを拡張するためのクラスです。


.. digraph:: essentials

    QtGui -> QtCore
    QtNetwork ->QtCore
    QtMultimedia ->QtGui
    QtQml -> QtCore
    QtQuick -> QtQml
    QtSql -> QtCore


.. rubric:: Qt Addon モジュール

Qtは基本モジュールのほかに、ソフトウェア開発者のための追加モジュールを提供しています。これらはQtのリリースには含まれません。以下は利用可能なアドオンモジュールのリストです。

* Qt 3D - 3Dグラフィックスプログラミングを簡単にするためのAPIのセット。
* Qt Bluetooth - Bluetoothワイヤレステクノロジーを使用するプラットフォームのためのC ++とQMLのAPI。
* Qt Contacts - アドレス帳/連絡先データベースにアクセスするためのC ++とQMLのAPI 
* Qt Location - 位置測位、マッピング、ナビゲーションおよび場所検索のためのQMLとC++のインターフェース。位置測位のためのNMEAバックエンド
* Qt Organizer - オーガナイザーイベント(todoやイベントなど)にアクセスするためのC ++とQMLのAPI
* Qt Publish and Subscribe
* Qt Sensors - センサーへアクセスするためのQMLとC ++インターフェース。
* Qt Service Framework - 通知を変更するための入力、ナビゲート、登録を有効にする。
* Qt System Info - システム関連の情報や機能を提供する。
* Qt Versit - vCardとiCalendar形式をサポートします。
* Qt Wayland - Linuxのみ。Qt Compositor API（サーバ）、およびWayland プラットフォームプラグイン(クライアント)が含まれています。
* Qt Feedback - ユーザのアクションに反応する触覚と音声のフィードバック。
* Qt JSON DB - Qt用のno-SQLオブジェクトストア。

.. note::

 以上のモジュールはリリースの一部ではありません。開発状況はアクティブなコントリビューターの数やテスト状況に依存するため、モジュールによって異なります。

対応プラットフォーム
-------------------

Qtはさまざまなプラットフォームをサポートしています。主要なデスクトップと組み込みプラットフォームは全てサポートしています。また、Qt Application Abstractionによって独自プラットフォームへのQtの移植は簡単に行えるようになりました。

Qt5のプラットフォーム上でのテストは時間がかかるものです。Qt Projectでは選別したプラットフォームの一部を標準プラットフォームとしてQt5のビルドを提供しています。これらのプラットフォームでは最高品質を確保するために、システムテストによる徹底的なテストが行われます。しかし念のために言っておきます「エラーのないコードなど存在しません」




Qt プロジェクト
==========

`Qt Project wiki <http://wiki.qt.io/>`_ より引用:

「Qtのプロジェクトは、Qtに興味を持つ同志による、実力主義のコンセンサスベースのコミュニティです。Qtに関心がある誰もがコミュニティに参加し、意思決定プロセスに関わり、Qtの発展に貢献することができます」

QtプロジェクトはQtのオープンソース部分を開発する組織です。この組織はユーザーがQtに貢献するための母体となります。最大の貢献者はQtの商業権を保持しているDIGIAです。

Qtはオープンソースの側面と企業のための商業的な側面を持っています。商業的な側面は、オープンソースライセンスにできない、あるいは適応したくない企業のためにあります。しかし商業的な側面がなければ、多くの企業がQtを使用することができませんし、DIGIAがQtのプロジェクトに非常に多くのコードを貢献することもできませんでした。

世界には、様々なプラットフォーム上でQtを使用したコンサルティングや製品開発を生業とする企業がたくさんあります。主要な開発ライブラリとしてQtに依存しているオープンソースプロジェクトとオープンソースの開発者も数多く存在しています。この活気に満ちたコミュニティの一員として、この素晴らしいツールとライブラリを使って働くことは心地のいいものです。Qtプロジェクトはあなたを成長させてくれる？多分ね :-)

**ここで貢献しよう: http://wiki.qt.io/**